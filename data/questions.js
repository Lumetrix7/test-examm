// Все 156 вопросов экзамена по Python ООП
const examQuestions = {
    sections: {
        section1: {
            name: "Раздел I. Основы ООП, Классы и Объекты",
            questions: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        },
        section2: {
            name: "Раздел II. Инкапсуляция и Свойства",
            questions: [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45]
        },
        section3: {
            name: "Раздел III. Наследование, Полиморфизм и Структура",
            questions: [46, 47, 48, 49, 50, 51, 52, 53, 54, 55]
        },
        section4: {
            name: "Раздел IV. Специальные методы и Автоматизация",
            questions: [56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90]
        },
        section5: {
            name: "Раздел V. Обработка Ошибок и Принципы Проектирования",
            questions: [91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156]
        }
    },

    questions: [
        // Раздел I: Вопросы 1-10
        {
            id: 1,
            text: "Что представляет собой класс?",
            options: [
                "A. Конкретная реализация атрибутов и методов в памяти.",
                "B. Шаблон или чертеж для создания объектов с определенными характеристиками.",
                "C. Функция, которая возвращает экземпляр объекта.",
                "D. Скрытое хранилище для приватных переменных.",
                "E. Метод для инициализации состояния объекта.",
                "F. Статический набор данных, который нельзя изменить."
            ],
            correctAnswers: ["B"],
            section: "section1"
        },
        {
            id: 2,
            text: "Какой специальный метод используется для инициализации атрибутов нового экземпляра класса?",
            options: [
                "A. __init__",
                "B. __new__",
                "C. __create__",
                "D. __start__",
                "E. __instance__",
                "F. __setup__"
            ],
            correctAnswers: ["A"],
            section: "section1"
        },
        {
            id: 3,
            text: "Что из перечисленного верно относительно переменных класса (Class variables)?",
            options: [
                "A. Они определяются внутри методов экземпляра.",
                "B. Они используются для хранения данных, общих для всех экземпляров класса.",
                "C. Они объявляются непосредственно внутри тела класса, вне каких-либо методов.",
                "D. Они доступны только через специальный метод __slots__.",
                "E. Их значения всегда уникальны для каждого объекта.",
                "F. Изменение переменной класса влияет только на тот экземпляр, через который произошло изменение."
            ],
            correctAnswers: ["B", "C"],
            section: "section1"
        },
        {
            id: 4,
            text: "Какова основная роль метода __new__ в жизненном цикле объекта?",
            options: [
                "A. Инициализировать состояние объекта после его создания и определения его поведения.",
                "B. Выполнять валидацию данных, переданных в конструктор.",
                "C. Непосредственно создавать и возвращать новый экземпляр класса.",
                "D. Определять строковое представление объекта.",
                "E. Вычислять хеш объекта.",
                "F. Управлять контекстом при использовании специального оператора with."
            ],
            correctAnswers: ["C"],
            section: "section1"
        },
        {
            id: 5,
            text: "Что является первым обязательным аргументом всех методов экземпляра (Instance methods)?",
            options: [
                "A. cls",
                "B. instance",
                "C. self",
                "D. obj",
                "E. this",
                "F. class_ref"
            ],
            correctAnswers: ["C"],
            section: "section1"
        },
        {
            id: 6,
            text: "В каком случае переменные класса и переменные экземпляра будут иметь одинаковые значения?",
            options: [
                "A. Если переменная экземпляра не была явно переопределена в экземпляре.",
                "B. Если переменная класса имеет префикс _.",
                "C. Если объект был создан с использованием __slots__.",
                "D. Если переменная класса объявлена как статическая и требует дополнительных значении.",
                "E. Если оба атрибута являются приватными и определены вне __init__.",
                "F. Если используется декоратор @property."
            ],
            correctAnswers: ["A"],
            section: "section1"
        },
        {
            id: 7,
            text: "Что из перечисленного является особенностью Статических методов (Static methods)?",
            options: [
                "A. Они принимают первым аргументом ссылку на экземпляр (self).",
                "B. Они принимают первым аргументом ссылку на класс (cls).",
                "C. Они не имеют неявного первого аргумента (ни self, ни cls).",
                "D. Для их объявления используется декоратор @staticmethod.",
                "E. Они не могут изменять состояние класса.",
                "F. Для их объявления используется декоратор @classmethod."
            ],
            correctAnswers: ["C", "D"],
            section: "section1"
        },
        {
            id: 8,
            text: "Какой принцип ООП в первую очередь связан с ограничением прямого доступа к внутреннему состоянию объекта и сокрытием деталей реализации?",
            options: [
                "A. Полиморфизм",
                "B. Наследование",
                "C. Абстракция",
                "D. Инкапсуляция",
                "E. Делегирование",
                "F. Композиция"
            ],
            correctAnswers: ["D"],
            section: "section1"
        },
        {
            id: 9,
            text: "Какой синтаксис используется для обозначения приватных?",
            options: [
                "A. public_attr",
                "B. _protected_attr",
                "C. __private_attr__",
                "D. __name_mangling_attr",
                "E. #comment_attr",
                "F. final_attr"
            ],
            correctAnswers: ["B"],
            section: "section1"
        },
        {
            id: 10,
            text: "Что такое Искажение имени (Name Mangling) в Python и когда оно применяется?",
            options: [
                "A. Это механизм для создания Read-only свойств.",
                "B. Это автоматическое изменение имени атрибута, чтобы избежать конфликтов в подклассах.",
                "C. Это применяется, когда имя атрибута начинается с двойного подчеркивания (__).",
                "D. Это способ, которым Python гарантирует, что приватные атрибуты абсолютно недоступны извне класса.",
                "E. Это используется для реализации паттерна Factory.",
                "F. Это механизм для автоматической генерации __repr__ с помощью dataclass."
            ],
            correctAnswers: ["B", "C"],
            section: "section1"
        },
        // Раздел II: Вопросы 11-45
        {
            id: 11,
            text: "Что является основной целью реализации Setter-метода при управлении доступом к атрибуту?",
            options: [
                "A. Создать алиас для атрибута.",
                "B. Возвращать строковое представление атрибута.",
                "C. Вычислить значение атрибута на лету (Computed property) тем самым сэкономив время.",
                "D. Предотвратить любое изменение атрибута.",
                "E. Обеспечить доступ к атрибуту только изнутри класса.",
                "F. Выполнять валидацию и проверку корректности присваиваемого значения."
            ],
            correctAnswers: ["F"],
            section: "section2"
        },
        {
            id: 12,
            text: "Какое преимущество дает использование свойств (@property) по сравнению с прямым доступом к атрибуту?",
            options: [
                "A. Позволяет изменить внутреннюю реализацию без изменения кода.",
                "B. Повышает эффективность памяти с помощью __slots__ вместо __dict__.",
                "C. Гарантирует, что атрибут станет статическим.",
                "D. Упрощает синтаксис множественного наследования.",
                "E. Использует __new__ для более быстрого создания.",
                "F. Является обязательным условием для использования dataclass и магических методов."
            ],
            correctAnswers: ["A"],
            section: "section2"
        },
        {
            id: 13,
            text: "Как объявляется Read-only property с использованием декораторов?",
            options: [
                "A. Созданием только Getter'а (@property) без Setter'а.",
                "B. Созданием только Setter'а (@attr.setter) без Getter'а.",
                "C. Использованием специального декоратора @readonly.",
                "D. Использованием property(fset=None).",
                "E. Применением __slots__ и __new__.",
                "F. Реализацией метода __eq__ и __hash__."
            ],
            correctAnswers: ["A"],
            section: "section2"
        },
        {
            id: 14,
            text: "Для чего используется __slots__ в классе Python?",
            options: [
                "A. Для определения статических методов.",
                "B. Для ограничения набора атрибутов.",
                "C. Для автоматической генерации dunder-методов, как в dataclass.",
                "D. Для принудительного создания словаря __dict__ у каждого экземпляра.",
                "E. Для предотвращения создания словаря __dict__ и ускорения доступа к атрибутам.",
                "F. Для запрета наследования класса."
            ],
            correctAnswers: ["B", "E"],
            section: "section2"
        },
        {
            id: 15,
            text: "Какая функция используется для создания свойства, если не используются декораторы?",
            options: [
                "A. attr()",
                "B. delegate()",
                "C. property()",
                "D. setter()",
                "E. getter()",
                "F. method()"
            ],
            correctAnswers: ["C"],
            section: "section2"
        },
        {
            id: 16,
            text: "Что такое Дескриптор данных (Data Descriptor)?",
            options: [
                "A. Объект, который реализует только метод __get__.",
                "B. Объект, который реализует метод __set__ или __delete__.",
                "C. Это механизм, на котором в Python основана работа свойств (@property).",
                "D. Это метод класса для работы с атрибутами экземпляра.",
                "E. Объект, используемый для dataclass с параметром frozen=True.",
                "F. Это специальный тип исключения для ошибок ввода-вывода."
            ],
            correctAnswers: ["B", "C"],
            section: "section2"
        },
        {
            id: 17,
            text: "В какой момент следует использовать публичное имя свойства в конструкторе __init__?",
            options: [
                "A. Никогда, всегда используем приватное имя (obj._attr) для точности.",
                "B. Только для переменных класса.",
                "C. Только если класс наследуется.",
                "D. Всегда, чтобы гарантировать запуск логики валидации в Setter'е.",
                "E. Только с реализацией Read-only свойств в самом классе.",
                "F. Только если класс является абстрактным."
            ],
            correctAnswers: ["D"],
            section: "section2"
        },
        {
            id: 18,
            text: "Какое правило ООП нарушается, если высокоуровневый код напрямую создает и использует конкретный низкоуровневый объект?",
            options: [
                "A. SRP",
                "B. OCP",
                "C. LSP",
                "D. ISP",
                "E. DIP"
            ],
            correctAnswers: ["E"],
            section: "section2"
        },
        {
            id: 19,
            text: "Что является классом в парадигме ООП?",
            options: [
                "A. Специальный метод для инициализации новых обьектов.",
                "B. Тип, который определяет состояние и поведение.",
                "C. Конкретный экземпляр, находящийся в памяти.",
                "D. Чертеж или шаблон, по которому создаются объекты.",
                "E. Первый аргумент метода экземпляра.",
                "F. Набор статических функций, объединённых общей логикой."
            ],
            correctAnswers: ["B", "D"],
            section: "section2"
        },
        {
            id: 20,
            text: "Когда в Python используется двойное подчеркивание (__) перед именем атрибута?",
            options: [
                "A. Для объявления переменной класса.",
                "B. Для объявления переменной экземпляра.",
                "C. Для активации Искажения имени.",
                "D. Для объявления статического метода.",
                "E. Для создания дескриптора.",
                "F. Для объявления свойства."
            ],
            correctAnswers: ["C"],
            section: "section2"
        },
        {
            id: 21,
            text: "Какой специальный метод вызывается, когда вы пытаетесь удалить свойство?",
            options: [
                "A. __del__",
                "B. del()",
                "C. @prop.deleter",
                "D. @prop.setter",
                "E. @prop.getter",
                "F. __deleter__"
            ],
            correctAnswers: ["C"],
            section: "section2"
        },
        {
            id: 22,
            text: "Что из перечисленного является функцией Getter-метода?",
            options: [
                "A. Изменение значения атрибута.",
                "B. Возврат значения атрибута.",
                "C. Реализация полиморфизма.",
                "D. Создание нового экземпляра.",
                "E. Объявление статического метода.",
                "F. Удаление атрибута."
            ],
            correctAnswers: ["B"],
            section: "section2"
        },
        {
            id: 23,
            text: "Какой механизм используется для реализации безопасного доступа к приватным атрибутам?",
            options: [
                "A. Использование __slots__.",
                "B. Применение Getter- и Setter-методов.",
                "C. Использование только свойств (@property).",
                "D. Создание только статических методов.",
                "E. Использование __new__.",
                "F. Реализация __hash__."
            ],
            correctAnswers: ["B", "C"],
            section: "section2"
        },
        {
            id: 24,
            text: "Что является основным недостатком отсутствия валидации в Setter-методе?",
            options: [
                "A. Возрастает потребение оперативной памяти объекта класса.",
                "B. Нарушается принцип наследования Open-Closed Principle (OCP).",
                "C. Невозможно будет использовать автоматическую генерацию методов в dataclass.",
                "D. Прекращается работа механизма MRO, что вызывает конфликт.",
                "E. Внутреннее состояние объекта может быть повреждено неверными данными.",
                "F. Свойство перестанет работать как Дескриптор данных класса."
            ],
            correctAnswers: ["E"],
            section: "section2"
        },
        {
            id: 25,
            text: "При создании свойства с использованием декоратора @property, какой декоратор используется для определения логики записи?",
            options: [
                "A. @set_value",
                "B. @property.setter",
                "C. @property.set",
                "D. @имя_свойства.setter",
                "E. @setter",
                "F. @set_method"
            ],
            correctAnswers: ["D"],
            section: "section2"
        },
        {
            id: 26,
            text: "Какой из методов вызывается первым при создании экземпляра класса?",
            options: [
                "A. __init__",
                "B. __repr__",
                "C. __new__",
                "D. @property",
                "E. @staticmethod",
                "F. __slots__"
            ],
            correctAnswers: ["C"],
            section: "section2"
        },
        {
            id: 27,
            text: "Что происходит при использовании __slots__?",
            options: [
                "A. Запрещается создание словаря __dict__ для экземпляра.",
                "B. Включается Name Mangling.",
                "C. Принудительно вызывается __new__.",
                "D. Атрибуты становятся дескрипторами.",
                "E. Атрибуты становятся статическими.",
                "F. Атрибуты становятся Read-only."
            ],
            correctAnswers: ["A"],
            section: "section2"
        },
        {
            id: 28,
            text: "Чем отличается Статический метод от Метода экземпляра?",
            options: [
                "A. Статический метод может изменять состояние экземпляра.",
                "B. Метод экземпляра принимает self и работает с данными объекта.",
                "C. Статический метод принимает cls.",
                "D. Статический метод не принимает self или cls и не работает с данными экземпляра.",
                "E. Метод экземпляра объявляется с @staticmethod.",
                "F. Статический метод реализует __slots__."
            ],
            correctAnswers: ["B", "D"],
            section: "section2"
        },
        {
            id: 29,
            text: "Что из перечисленного верно относительно Getter-метода?",
            options: [
                "A. Читает значение атрибута",
                "B. Изменяет значение атрибута",
                "C. Использует декоратор @property",
                "D. Заменяет метод new",
                "E. Должен быть статическим",
                "F. Работает только с наследованием"
            ],
            correctAnswers: ["A", "C"],
            section: "section2"
        },
        {
            id: 30,
            text: "Какова цель Искажения имени (Name Mangling)?",
            options: [
                "A. Защита атрибутов от переопределения",
                "B. Создание неизменяемых свойств",
                "C. Автоматическое наследование классов",
                "D. Применение полиморфизма объектов",
                "E. Обход валидации Setter-метода",
                "F. Автоматический вызов init"
            ],
            correctAnswers: ["B"],
            section: "section2"
        },
        {
            id: 31,
            text: "Что используется для создания отношения наследования между классами?",
            options: [
                "A. extends",
                "B. inherits",
                "C. super",
                "D. ()",
                "E. childof",
                "F. uses"
            ],
            correctAnswers: ["D"],
            section: "section2"
        },
        {
            id: 32,
            text: "Что такое MRO (Method Resolution Order) и для чего он нужен?",
            options: [
                "A. Логика равенства объектов",
                "B. Заменяемость подклассов",
                "C. Порядок поиска методов при множественном наследовании",
                "D. Сортировка dunder-методов",
                "E. Вызов статических методов",
                "F. Решение ромбовидной проблемы"
            ],
            correctAnswers: ["C", "F"],
            section: "section2"
        },
        {
            id: 33,
            text: "Для чего используется функция super()?",
            options: [
                "A. Создание экземпляра",
                "B. Активация искажения имен",
                "C. Делегирование родителю",
                "D. Вызов переопределенных методов",
                "E. Строковое представление",
                "F. Реализация абстракций"
            ],
            correctAnswers: ["C", "D"],
            section: "section2"
        },
        {
            id: 34,
            text: "Какое из утверждений верно относительно переопределения методов?",
            options: [
                "A. Требует @override",
                "B. Дочерний класс перекрывает родительский",
                "C. Вызывает ошибку MRO",
                "D. Использует new",
                "E. Создает свойства",
                "F. Только для статических"
            ],
            correctAnswers: ["B"],
            section: "section2"
        },
        {
            id: 35,
            text: "Что такое Полиморфизм в контексте ООП?",
            options: [
                "A. Использование __slots__ для экономии памяти.",
                "B. Принцип, согласно которому класс может иметь только одну ответственность.",
                "C. Метод, который всегда возвращает None.",
                "D. Способность объектов разных классов отвечать на одно и то же сообщение по-разному.",
                "E. Отношение \"является частью\" (Part-of).",
                "F. Использование только приватных атрибутов."
            ],
            correctAnswers: ["D"],
            section: "section2"
        },
        {
            id: 36,
            text: "Что такое Абстрактный класс и какой модуль используется для его создания?",
            options: [
                "A. Класс, который не может быть инстанцирован напрямую.",
                "B. Класс, который обязан реализовывать все методы с декоратором @staticmethod.",
                "C. Класс, который содержит Абстрактные методы (методы без реализации).",
                "D. Класс, используемый только для dataclass.",
                "E. Используется модуль abc.",
                "F. Используется модуль abcsys."
            ],
            correctAnswers: ["A", "E"],
            section: "section2"
        },
        {
            id: 37,
            text: "Какой принцип ООП нарушается, если подкласс не может полностью заменить базовый класс без изменения клиентского кода?",
            options: [
                "A. SRP (Single Responsibility Principle)",
                "B. OCP (Open-Closed Principle)",
                "C. LSP (Liskov Substitution Principle)",
                "D. ISP (Interface Segregation Principle)",
                "E. DIP (Dependency Inversion Principle)"
            ],
            correctAnswers: ["C"],
            section: "section2"
        },
        {
            id: 38,
            text: "Какое правило должно соблюдаться при реализации абстрактных методов в дочернем классе?",
            options: [
                "A. Они должны быть реализованы как статические и не могут быть переопределены.",
                "B. Они должны использовать __slots__.",
                "C. Они должны быть реализованы с той же сигнатурой, что и в родительском классе.",
                "D. Они должны быть реализованы только с помощью @property.",
                "E. Они должны быть реализованы только с помощью dataclass."
            ],
            correctAnswers: ["C"],
            section: "section2"
        },
        {
            id: 39,
            text: "Какой специальный метод вызывается функцией print() для получения удобочитаемого строкового представления объекта?",
            options: [
                "A. __repr__",
                "B. __str__",
                "C. __unicode__",
                "D. __format__",
                "E. __display__",
                "F. __show__"
            ],
            correctAnswers: ["B"],
            section: "section2"
        },
        {
            id: 40,
            text: "Какой специальный метод должен возвращать недвусмысленное строковое представление объекта, которое в идеале может быть использовано для восстановления объекта (для разработчика)?",
            options: [
                "A. __str__",
                "B. __log__",
                "C. __debug__",
                "D. __print__",
                "E. __display__",
                "F. __repr__"
            ],
            correctAnswers: ["F"],
            section: "section2"
        },
        {
            id: 41,
            text: "Какой специальный метод используется для определения логики равенства между двумя объектами?",
            options: [
                "A. __hash__",
                "B. __init__",
                "C. __eq__",
                "D. __equal__",
                "E. __new__",
                "F. __slots__"
            ],
            correctAnswers: ["C"],
            section: "section2"
        },
        {
            id: 42,
            text: "Что является главным требованием к классу, если вы реализуете метод __hash__?",
            options: [
                "A. Класс должен быть абстрактным.",
                "B. Класс должен быть неизменяемым или иметь неизменяемые атрибуты для хеша.",
                "C. Класс должен использовать __slots__.",
                "D. Класс должен иметь только статические методы.",
                "E. Класс должен наследоваться от abc.",
                "F. Класс должен использовать только приватные атрибуты для хранения внутренних данных."
            ],
            correctAnswers: ["B"],
            section: "section2"
        },
        {
            id: 43,
            text: "Какой специальный метод используется для определения логического преобразования объекта?",
            options: [
                "A. __true__",
                "B. __false__",
                "C. __bool__",
                "D. __logic__",
                "E. __if__",
                "F. __test__"
            ],
            correctAnswers: ["C"],
            section: "section2"
        },
        {
            id: 44,
            text: "Какой специальный метод используется для входа в контекст при работе с оператором with?",
            options: [
                "A. __enter__",
                "B. __exit__",
                "C. __context__",
                "D. __new__",
                "E. __open__",
                "F. __start__"
            ],
            correctAnswers: ["A"],
            section: "section2"
        },
        {
            id: 45,
            text: "Какой специальный метод используется для выхода из контекста при работе с оператором with и обработки возможных исключений?",
            options: [
                "A. __exit__",
                "B. __slots__",
                "C. __close__",
                "D. __finally__",
                "E. __stop__",
                "F. __del__"
            ],
            correctAnswers: ["A"],
            section: "section2"
        },
        // Раздел III: Вопросы 46-55
        {
            id: 46,
            text: "Какой декоратор используется для автоматической генерации dunder-методов?",
            options: [
                "A. @classproperty",
                "B. @abstractmethod",
                "C. @dataclass",
                "D. @property",
                "E. @staticmethod",
                "F. @classmethod"
            ],
            correctAnswers: ["C"],
            section: "section3"
        },
        {
            id: 47,
            text: "Что такое Метаклассы (Metaclasses)?",
            options: [
                "A. Классы создающие другие классы",
                "B. Базовые классы для наследования",
                "C. Классы только с dunder-методами",
                "D. Классы для dataclass создания",
                "E. Классы только со статическими методами",
                "F. Абстрактные классы для интерфейсов"
            ],
            correctAnswers: ["A"],
            section: "section3"
        },
        {
            id: 48,
            text: "Что такое Перечисление?",
            options: [
                "A. Набор констант с уникальными значениями",
                "B. Механизм приватных методов",
                "C. Способ создания неизменяемых свойств",
                "D. Логика для хеширования объектов",
                "E. Порядок разрешения методов MRO",
                "F. Создание абстрактных базовых классов"
            ],
            correctAnswers: ["A"],
            section: "section3"
        },
        {
            id: 49,
            text: "Когда используется Композиция как предпочтительная альтернатива наследованию?",
            options: [
                "A. При отношении \"имеет компонент\" Has-a",
                "B. При полном соответствии Is-a родителю",
                "C. При разрешении конфликтов MRO",
                "D. При создании абстрактных классов",
                "E. При вызове super() в иерархии",
                "F. При работе с dataclass структурами"
            ],
            correctAnswers: ["A"],
            section: "section3"
        },
        {
            id: 50,
            text: "Что означает \"открыт для расширения, закрыт для модификации\"?",
            options: [
                "A. SRP",
                "B. LSP",
                "C. ISP",
                "D. OCP",
                "E. DIP"
            ],
            correctAnswers: ["D"],
            section: "section3"
        },
        {
            id: 51,
            text: "Какой принцип SOLID утверждает, что высокоуровневые модули не должны зависеть от низкоуровневых модулей, а оба должны зависеть от абстракций?",
            options: [
                "A. OCP",
                "B. LSP",
                "C. ISP",
                "D. DIP",
                "E. SRP"
            ],
            correctAnswers: ["D"],
            section: "section3"
        },
        {
            id: 52,
            text: "Что такое модули высокого уровня в контексте DIP?",
            options: [
                "A. Детали реализации.",
                "B. Бизнес-логика и координация.",
                "C. Абстрактные классы.",
                "D. Классы, использующие __slots__.",
                "E. Классы, использующие dataclass.",
                "F. Классы, использующие super()."
            ],
            correctAnswers: ["B"],
            section: "section3"
        },
        {
            id: 53,
            text: "Что такое модули низкого уровня в контексте DIP?",
            options: [
                "A. Детали реализации.",
                "B. Бизнес-логика.",
                "C. Абстракции.",
                "D. Классы, использующие super().",
                "E. Классы, использующие dataclass.",
                "F. Классы, использующие MRO."
            ],
            correctAnswers: ["A"],
            section: "section3"
        },
        {
            id: 54,
            text: "Какой принцип SOLID гласит, что клиенты не должны зависеть от методов интерфейса, которые они не используют?",
            options: [
                "A. SRP",
                "B. OCP",
                "C. LSP",
                "D. ISP",
                "E. DIP"
            ],
            correctAnswers: ["D"],
            section: "section3"
        },
        {
            id: 55,
            text: "При каком условии класс, реализующий __eq__, должен также реализовать __hash__?",
            options: [
                "A. Класс является полностью абстрактным базовым типом.",
                "B. Используется как ключ словаря или множества.",
                "C. Класс применяет метод super() в иерархии.",
                "D. Класс использует декоратор dataclass для упрощения.",
                "E. Класс применяет __slots__ для оптимизации памяти.",
                "F. Класс реализован только для чтения после инициализации."
            ],
            correctAnswers: ["B"],
            section: "section3"
        },
        // Раздел IV: Вопросы 56-90
        {
            id: 56,
            text: "Какое исключение нужно использовать для сообщения о невалидности данных в Setter-методе?",
            options: [
                "A. KeyError",
                "B. IOError",
                "C. IndexError",
                "D. ValueError или TypeError.",
                "E. AttributeError",
                "F. NotImplementedError"
            ],
            correctAnswers: ["D"],
            section: "section4"
        },
        {
            id: 57,
            text: "Какой принцип SOLID утверждает, что один класс должен иметь только одну причину для изменения?",
            options: [
                "A. OCP",
                "B. LSP",
                "C. ISP",
                "D. DIP",
                "E. SRP"
            ],
            correctAnswers: ["E"],
            section: "section4"
        },
        {
            id: 58,
            text: "Что такое Duck Typing в контексте Полиморфизма?",
            options: [
                "A. Механизм, применяемый для оптимизации памяти с помощью __slots__.",
                "B. Принцип «Если объект ведет себя как утка, значит это утка».",
                "C. Механизм, использующий Name Mangling для скрытия атрибутов.",
                "D. Механизм, учитывающий порядок MRO при вызове методов.",
                "E. Принцип, применяемый при создании и использовании dataclass.",
                "F. Принцип, используемый при реализации метода __hash__ в классе."
            ],
            correctAnswers: ["B"],
            section: "section4"
        },
        {
            id: 59,
            text: "Какой из перечисленных принципов SOLID напрямую поощряет использование абстракций и интерфейсов?",
            options: [
                "A. OCP",
                "B. SRP",
                "C. LSP",
                "D. DIP",
                "E. MRO"
            ],
            correctAnswers: ["A", "D"],
            section: "section4"
        },
        {
            id: 60,
            text: "Какая из структур лучше всего подходит для представления набора неизменяемых констант в Python?",
            options: [
                "A. dataclass",
                "B. Класс с __slots__",
                "C. Перечисление",
                "D. Абстрактный класс",
                "E. Класс с __new__",
                "F. Класс с _name"
            ],
            correctAnswers: ["C"],
            section: "section4"
        },
        {
            id: 61,
            text: "Что произойдет, если вы попытаетесь создать объект от класса, который имеет абстрактные методы, но не реализовал их?",
            options: [
                "A. Создастся Read-only объект.",
                "B. Произойдет ошибка TypeError.",
                "C. Будет вызван __slots__.",
                "D. Будет вызван Name Mangling.",
                "E. Будет вызван __new__.",
                "F. Объект станет хешируемым."
            ],
            correctAnswers: ["B"],
            section: "section4"
        },
        {
            id: 62,
            text: "Для чего необходимо реализовывать __hash__ совместно с __eq__?",
            options: [
                "A. Чтобы объекты всегда использовали стандартный repr для вывода.",
                "B. Чтобы объекты, которые равны, имели одинаковый хеш.",
                "C. Чтобы объект всегда имел уникальный идентификатор независимо от равенства.",
                "D. Чтобы объекты могли сравниваться по ссылке, а не по значению.",
                "E. Чтобы объекты автоматически становились неизменяемыми.",
                "F. Чтобы объекты можно было сериализовать в JSON без ошибок."
            ],
            correctAnswers: ["B"],
            section: "section4"
        },
        {
            id: 63,
            text: "Какая из концепций связана с \"утиной типизацией\" (Duck Typing)?",
            options: [
                "A. Жёсткое наследование только от одного класса.",
                "B. Принудительная проверка типов через isinstance().",
                "C. Полиморфизм через совместимость поведения объектов.",
                "D. Сокрытие атрибутов и методов класса.",
                "E. Автоматическая генерация dataclass.",
                "F. Статическая проверка типов через аннотации."
            ],
            correctAnswers: ["C"],
            section: "section4"
        },
        {
            id: 64,
            text: "Что является основным требованием для того, чтобы класс мог использовать контекстные менеджеры?",
            options: [
                "A. Использование __slots__.",
                "B. Использование dataclass.",
                "C. Реализация методов __enter__ и __exit__.",
                "D. Реализация только статических методов.",
                "E. Реализация только Read-only свойств.",
                "F. Реализация __hash__."
            ],
            correctAnswers: ["C"],
            section: "section4"
        },
        {
            id: 65,
            text: "Какая главная цель Инкапсуляции в ООП?",
            options: [
                "A. Сокрытие деталей реализации",
                "B. Автоматическая оптимизация памяти",
                "C. Генерация конструкторов классов",
                "D. Реализация полиморфизма",
                "E. Создание абстрактных базовых классов",
                "F. Упрощение множественного наследования."
            ],
            correctAnswers: ["A"],
            section: "section4"
        },
        {
            id: 66,
            text: "Какой синтаксис используется в Python для обозначения приватных методов (по соглашению)?",
            options: [
                "A. method_public()",
                "B. _method_internal()",
                "C. __method_hidden()",
                "D. method_secure()",
                "E. final_method()",
                "F. static_method()"
            ],
            correctAnswers: ["B"],
            section: "section4"
        },
        {
            id: 67,
            text: "Какое преимущество дает реализация безопасного доступа к приватным атрибутам через Getter/Setter?",
            options: [
                "A. Автоматическая сериализация объектов",
                "B. Контроль и проверка данных при доступе",
                "C. Возможность смены логики без изменения интерфейса",
                "D. Ускорение работы с хеш-таблицами",
                "E. Обязательное применение MRO",
                "F. Создание неизменяемых dataclass."
            ],
            correctAnswers: ["B", "C"],
            section: "section4"
        },
        {
            id: 68,
            text: "Когда и почему Python применяет Искажение имени (Name Mangling)?",
            options: [
                "A. При наличии одного подчеркивания",
                "B. Для работы с @classmethod",
                "C. При двойном подчеркивании в начале",
                "D. Избежание перекрытия атрибутов в наследниках",
                "E. Автоматическое кэширование свойств",
                "F. Оптимизация доступа к атрибутам класса"
            ],
            correctAnswers: ["C", "D"],
            section: "section4"
        },
        {
            id: 69,
            text: "Какова основная проблема прямого доступа к атрибутам класса?",
            options: [
                "A. Нарушение LSP.",
                "B. Отсутствие контроля при присвоении значений.",
                "C. Усложнение MRO.",
                "D. Невозможность наследования",
                "E. Принудительное использование статических методов.",
                "F. Слишком большая экономия памяти."
            ],
            correctAnswers: ["B"],
            section: "section4"
        },
        {
            id: 70,
            text: "Что такое Свойство (Property) в Python?",
            options: [
                "A. Доступ к методам как к атрибутам",
                "B. Автоматическая сериализация объектов",
                "C. Генератор конструкторов классов",
                "D. Оптимизатор памяти через слоты",
                "E. Реализация множественного наследования",
                "F. Кэширование атрибутов экземпляра"
            ],
            correctAnswers: ["A"],
            section: "section4"
        },
        {
            id: 71,
            text: "При использовании декораторов, какой декоратор используется для определения Getter-логики свойства?",
            options: [
                "A. @setter",
                "B. @getter",
                "C. @property",
                "D. @deleter",
                "E. @staticmethod",
                "F. @classmethod"
            ],
            correctAnswers: ["C"],
            section: "section4"
        },
        {
            id: 72,
            text: "Как выглядит синтаксис для определения Setter-метода свойства value?",
            options: [
                "A. @value.property",
                "B. @value.getter",
                "C. @value.setter",
                "D. @property.setter",
                "E. @setter.value",
                "F. @value.delete"
            ],
            correctAnswers: ["C"],
            section: "section4"
        },
        {
            id: 73,
            text: "Что необходимо сделать, чтобы создать Read-only property?",
            options: [
                "A. Реализовать Getter-метод (@property).",
                "B. Объявить его как статическое.",
                "C. Реализовать только Setter-метод (@attr.setter).",
                "D. Применить двойное подчеркивание",
                "E. Не определять метод-setter для свойства",
                "F. Реализовать __new__ метод"
            ],
            correctAnswers: ["A", "E"],
            section: "section4"
        },
        {
            id: 74,
            text: "Что произойдет при попытке присвоить значение свойству, для которого не определен Setter?",
            options: [
                "A. Будет выброшено исключение AttributeError",
                "B. Setter будет создан автоматически",
                "C. Присваивание будет запрещено",
                "D. Значение сохранится в __dict__",
                "E. Будет повторно вызван __init__",
                "F. Начнётся поиск по MRO"
            ],
            correctAnswers: ["A", "C"],
            section: "section4"
        },
        {
            id: 75,
            text: "Для чего используется @attr.deleter?",
            options: [
                "A. Для освобождения памяти при удалении объекта.",
                "B. Для перехвата удаления экземпляра через del obj.",
                "C. Для задания поведения при выполнении del obj.attr.",
                "D. Для автоматического удаления атрибутов класса.",
                "E. Для очистки всех свойств экземпляра.",
                "F. Для сброса значения атрибута в None по умолчанию."
            ],
            correctAnswers: ["C"],
            section: "section4"
        },
        {
            id: 76,
            text: "Что такое Дескриптор (Descriptor) в Python?",
            options: [
                "A. Класс, который наследуется от object",
                "B. Объект, реализующий __get__, __set__ или __delete__",
                "C. Способ автоматической генерации атрибутов",
                "D. Механизм для оптимизации памяти",
                "E. Специальный тип свойства только для чтения",
                "F. Метод для переопределения MRO"
            ],
            correctAnswers: ["B"],
            section: "section4"
        },
        {
            id: 77,
            text: "Что используется для Искажения имени (Name Mangling)?",
            options: [
                "A. Одинарное подчёркивание в имени атрибута",
                "B. Использование декоратора @property",
                "C. Два подчёркивания в конце имени",
                "D. Два подчёркивания в начале имени атрибута",
                "E. Использование __slots__",
                "F. Переопределение __getattr__"
            ],
            correctAnswers: ["D"],
            section: "section4"
        },
        {
            id: 78,
            text: "Если свойство attr реализовано с помощью @property, как обратиться к Setter-методу?",
            options: [
                "A. Вызвать obj.attr.set(value).",
                "B. Вызвать obj.attr = value.",
                "C. Вызвать obj.set_attr(value).",
                "D. Вызвать obj.attr(value).",
                "E. Вызвать obj.setter(value).",
                "F. Вызвать obj._attr = value."
            ],
            correctAnswers: ["B"],
            section: "section4"
        },
        {
            id: 79,
            text: "Какой из принципов Инкапсуляции нарушается, если атрибут __balance изменяется напрямую извне класса, игнорируя Name Mangling?",
            options: [
                "A. Разделение ответственности",
                "B. Открытость для расширения",
                "C. Полиморфизм поведения",
                "D. Наследование реализации",
                "E. Принцип подстановки Лисков",
                "F. Сокрытие внутреннего состояния объекта"
            ],
            correctAnswers: ["F"],
            section: "section4"
        },
        {
            id: 80,
            text: "Какое имя приобретает приватный атрибут __data после применения Искажения имени в классе MyClass?",
            options: [
                "A. __data",
                "B. _data",
                "C. MyClass__data",
                "D. _MyClass__data",
                "E. __MyClass_data",
                "F. _MyClass_data"
            ],
            correctAnswers: ["D"],
            section: "section4"
        },
        {
            id: 81,
            text: "Что произойдет, если в классе с __slots__ = ['a', 'b'] попытаться присвоить значение атрибуту c?",
            options: [
                "A. Атрибут будет добавлен динамически",
                "B. Значение будет проигнорировано",
                "C. Возникнет AttributeError",
                "D. Атрибут будет добавлен в __dict__",
                "E. Интерпретатор создаст слот автоматически",
                "F. Объект станет неизменяемым"
            ],
            correctAnswers: ["C"],
            section: "section4"
        },
        {
            id: 82,
            text: "Какой из следующих вариантов является правильным для создания свойства с использованием класса Property?",
            options: [
                "A. x = property()",
                "B. x = property(get, set)",
                "C. x = property(self.get)",
                "D. @property(x)",
                "E. x = property(self.x)",
                "F. property = x"
            ],
            correctAnswers: ["B"],
            section: "section4"
        },
        {
            id: 83,
            text: "Что такое Getter-метод?",
            options: [
                "A. Метод, который изменяет значение атрибута",
                "B. Метод класса для доступа к данным",
                "C. Метод для удаления атрибута",
                "D. Метод для создания свойства",
                "E. Метод, возвращающий значение атрибута",
                "F. Статический метод без аргументов"
            ],
            correctAnswers: ["E"],
            section: "section4"
        },
        {
            id: 84,
            text: "При использовании свойства, как получить доступ к приватному атрибуту (_value) из Getter-метода?",
            options: [
                "A. return self.value",
                "B. return self._value",
                "C. return value",
                "D. return _value",
                "E. return super()._value",
                "F. return getattr(self, 'value')"
            ],
            correctAnswers: ["B"],
            section: "section4"
        },
        {
            id: 85,
            text: "Какой метод должен быть реализован в классе, чтобы он вел себя как Дескриптор, не являющийся данными (Non-Data Descriptor)?",
            options: [
                "A. __set__",
                "B. __delete__",
                "C. __get__",
                "D. __init__",
                "E. __slots__",
                "F. __new__"
            ],
            correctAnswers: ["C"],
            section: "section4"
        },
        {
            id: 86,
            text: "Где должны быть определены атрибуты, перечисленные в __slots__?",
            options: [
                "A. Внутри __init__.",
                "B. Внутри статического метода.",
                "C. Непосредственно в теле класса.",
                "D. Внутри Setter'а.",
                "E. Внутри Getter'а.",
                "F. Внутри __new__."
            ],
            correctAnswers: ["C"],
            section: "section4"
        },
        {
            id: 87,
            text: "Что обеспечивает контролируемое чтение атрибута?",
            options: [
                "A. Setter",
                "B. Getter",
                "C. Deleter",
                "D. slots",
                "E. Name Mangling",
                "F. super()"
            ],
            correctAnswers: ["B"],
            section: "section4"
        },
        {
            id: 88,
            text: "Какое из утверждений верно относительно Дескриптора, не являющегося данными (Non-Data Descriptor)?",
            options: [
                "A. Он всегда использует __slots__.",
                "B. Он может быть перекрыт обычным атрибутом экземпляра.",
                "C. Он реализует только __get__.",
                "D. Он реализует __set__.",
                "E. Он реализует __delete__.",
                "F. Он используется для статических методов."
            ],
            correctAnswers: ["B", "C"],
            section: "section4"
        },
        {
            id: 89,
            text: "Что такое Deleter-метод свойства?",
            options: [
                "A. Метод, который удаляет класс.",
                "B. Метод, который удаляет экземпляр.",
                "C. Метод, который определяет логику удаления внутреннего атрибута.",
                "D. Метод, который удаляет только статические перемнные.",
                "E. Метод, который удаляет соглашение о том, что атрибут защищен.",
                "F. Метод, который удаляет дескриптор."
            ],
            correctAnswers: ["C"],
            section: "section4"
        },
        {
            id: 90,
            text: "Что обеспечивает контролируемую запись?",
            options: [
                "A. Getter.",
                "B. Setter.",
                "C. Deleter.",
                "D. __slots__.",
                "E. __hash__.",
                "F. __dict__."
            ],
            correctAnswers: ["B"],
            section: "section4"
        },
        // Раздел V: Вопросы 91-156
        {
            id: 91,
            text: "Что является главной задачей метода __new__?",
            options: [
                "A. Инициализация атрибутов экземпляра.",
                "B. Непосредственное создание и возврат нового экземпляра класса до вызова __init__.",
                "C. Определение строкового представления объекта.",
                "D. Вычисление хеша объекта.",
                "E. Управление контекстом с помощью оператора with.",
                "F. Реализация полиморфизма."
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 92,
            text: "Что из перечисленного является особенностью Методов экземпляра (Instance methods)?",
            options: [
                "A. Они неявно принимают первым аргументом ссылку на класс (cls).",
                "B. Они всегда возвращают self.",
                "C. Они неявно принимают первым аргументом ссылку на экземпляр (self).",
                "D. Они могут изменять состояние конкретного экземпляра.",
                "E. Они не могут получить доступ к переменным класса.",
                "F. Они не могут использовать super()."
            ],
            correctAnswers: ["C", "D"],
            section: "section5"
        },
        {
            id: 93,
            text: "Как Статический метод может получить доступ к переменной класса, не имея ни self, ни cls?",
            options: [
                "A. Это невозможно.",
                "B. Через специальный декоратор @classaccess.",
                "C. Через вызов магических методов.",
                "D. Через __slots__.",
                "E. Путем прямого обращения к имени класса.",
                "F. Путем использования Name Mangling."
            ],
            correctAnswers: ["E"],
            section: "section5"
        },
        {
            id: 94,
            text: "Что произойдет, если в методе экземпляра отсутствует первый аргумент self?",
            options: [
                "A. Метод автоматически станет статическим.",
                "B. Метод автоматически станет приватным.",
                "C. Метод будет работать как Класс-метод.",
                "D. Метод будет работать как __new__.",
                "E. Выдаст ошибку TypeError при вызове метода.",
                "F. Метод будет использовать Name Mangling."
            ],
            correctAnswers: ["E"],
            section: "section5"
        },
        {
            id: 95,
            text: "Что произойдет, если в классе с __slots__ попытаться присвоить значение атрибуту, не входящему в список?",
            options: [
                "A. Сработает __new__.",
                "B. Сработает Name Mangling.",
                "C. Будет вызван __init__.",
                "D. Произойдет ошибка AttributeError.",
                "E. Будет создан словарь __dict__ для хранения этого атрибута.",
                "F. Будет вызван __bool__."
            ],
            correctAnswers: ["D"],
            section: "section5"
        },
        {
            id: 96,
            text: "Что обеспечивает контролируемый доступ на запись к атрибуту?",
            options: [
                "A. Getter-метод.",
                "B. Дескриптор, не являющийся данными.",
                "C. Read-only свойство.",
                "D. Name Mangling.",
                "E. Setter-метод.",
                "F. Дескриптор данных."
            ],
            correctAnswers: ["E", "F"],
            section: "section5"
        },
        {
            id: 97,
            text: "Что произойдет, если в классе с __slots__ попытаться добавить к нему еще один атрибут в __init__?",
            options: [
                "A. Атрибут будет добавлен, и будет создан словарь __dict__.",
                "B. Атрибут будет добавлен, но будет скрыт с помощью Name Mangling.",
                "C. __slots__ уже определен и не содержит этого имени.",
                "D. Атрибут будет добавлен, и будет вызван super().",
                "E. Произойдет ошибка AttributeError.",
                "F. Атрибут будет добавлен, и будет вызван __new__."
            ],
            correctAnswers: ["C", "E"],
            section: "section5"
        },
        {
            id: 98,
            text: "Что из перечисленного является особенностью Абстрактных классов?",
            options: [
                "A. Они предназначены только для хранения констант.",
                "B. Они не могут быть инстанцированы.",
                "C. Они создаются с помощью модуля abc и декоратора @abstractmethod.",
                "D. Они автоматически реализуют все методы наследников.",
                "E. Они применяются исключительно для функционального программирования.",
                "F. Они могут содержать только статические методы."
            ],
            correctAnswers: ["B", "C"],
            section: "section5"
        },
        {
            id: 99,
            text: "Что такое Множественное наследование?",
            options: [
                "A. Класс наследуется сразу от нескольких родительских классов.",
                "B. Класс реализует поведение нескольких базовых классов.",
                "C. Класс использует только один базовый интерфейс.",
                "D. Класс копирует методы других классов без наследования.",
                "E. Класс содержит другие объекты вместо наследования.",
                "F. Класс наследуется только от абстрактных классов."
            ],
            correctAnswers: ["A", "B"],
            section: "section5"
        },
        {
            id: 100,
            text: "Какой принцип ООП может быть нарушен, если метод в дочернем классе имеет ту же сигнатуру, что и в родительском, но выполняет совершенно иную, неожиданную операцию?",
            options: [
                "A. SRP.",
                "B. OCP.",
                "C. LSP.",
                "D. ISP.",
                "E. DIP."
            ],
            correctAnswers: ["C"],
            section: "section5"
        },
        {
            id: 101,
            text: "Что такое Агрегация?",
            options: [
                "A. Отношение, при котором один объект использует другой.",
                "B. Связь, основанная на полиморфизме.",
                "C. Жёсткая форма владения объектом (композиция).",
                "D. Наследование поведения одного класса другим.",
                "E. Создание объекта внутри конструктора без ссылки.",
                "F. Объекты могут существовать независимо друг от друга."
            ],
            correctAnswers: ["A", "F"],
            section: "section5"
        },
        {
            id: 102,
            text: "Какие методы должны быть реализованы в классе, чтобы он мог использоваться как Контекстный менеджер с оператором with?",
            options: [
                "A. __init__",
                "B. __new__",
                "C. __enter__",
                "D. __exit__",
                "E. __slots__",
                "F. __super__"
            ],
            correctAnswers: ["C", "D"],
            section: "section5"
        },
        {
            id: 103,
            text: "Что делает декоратор @dataclass?",
            options: [
                "A. Автоматически генерирует __init__.",
                "B. Генерирует методы сравнения объектов.",
                "C. Делает все атрибуты приватными.",
                "D. Запрещает изменение атрибутов.",
                "E. Реализует абстрактные методы.",
                "F. Включает оптимизацию памяти через __slots__."
            ],
            correctAnswers: ["A", "B"],
            section: "section5"
        },
        {
            id: 104,
            text: "Какой метод должен быть реализован для хешируемости объекта (возможность использовать его как ключ словаря или элемент множества)?",
            options: [
                "A. __str__",
                "B. __repr__",
                "C. __eq__",
                "D. __hash__",
                "E. __bool__",
                "F. __del__"
            ],
            correctAnswers: ["D"],
            section: "section5"
        },
        {
            id: 105,
            text: "Что такое Метакласс?",
            options: [
                "A. Класс, который является абстрактным.",
                "B. Абстрактный базовый класс без реализации.",
                "C. Класс для хранения метаданных экземпляров.",
                "D. Класс, который создает другие классы.",
                "E. Класс, экземплярами которого являются классы.",
                "F. Класс, который использует MRO."
            ],
            correctAnswers: ["D", "E"],
            section: "section5"
        },
        {
            id: 106,
            text: "Если класс FileLogger реализует логику записи в файл и логику форматирования сообщения, какой принцип SOLID нарушается?",
            options: [
                "A. OCP",
                "B. LSP",
                "C. ISP",
                "D. DIP",
                "E. SRP"
            ],
            correctAnswers: ["E"],
            section: "section5"
        },
        {
            id: 107,
            text: "Функция type(point) возвращает класс Point а isinstance(point, Point) подтверждает принадлежность где type используется для точного типа isinstance для иерархий наследования. Что возвращает type(point)?",
            options: [
                "A. id(point)",
                "B. Класс Point",
                "C. Адрес памяти",
                "D. Словарь атрибутов",
                "E. Метакласс",
                "F. Модуль"
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 108,
            text: "Атрибут __dict__['x'] = 5 в экземпляре Point хранит instance данные где прямое изменение __dict__ работает но setattr(point, 'z', 10) предпочтительнее для консистентности. Где хранится x у экземпляра?",
            options: [
                "A. Point.__dict__",
                "B. locals()",
                "C. globals()",
                "D. point.__dict__",
                "E. module.__dict__",
                "F. type.__dict__"
            ],
            correctAnswers: ["D"],
            section: "section5"
        },
        {
            id: 109,
            text: "Динамическое удаление атрибута через delattr(point, 'temp') или del point.temp очищает __dict__ экземпляра где повторное обращение вызовет AttributeError стандартно. Какой метод удаляет динамически?",
            options: [
                "A. removeattr()",
                "B. rmattr()",
                "C. clearattr()",
                "D. dropattr()",
                "E. unsetattr()",
                "F. delattr()"
            ],
            correctAnswers: ["F"],
            section: "section5"
        },
        {
            id: 110,
            text: "Атрибут _balance в BankAccount доступен через value() но прямое изменение нарушает инкапсуляцию. Что означает _balance?",
            options: [
                "A. Публичный",
                "B. Константа",
                "C. Статический",
                "D. Приватный по соглашению",
                "E. Readonly",
                "F. Глобальный"
            ],
            correctAnswers: ["D"],
            section: "section5"
        },
        {
            id: 111,
            text: "Двойное подчеркивание __secret в Temperature искажается до _Temperature__secret где point. Что создает __ в начале?",
            options: [
                "A. Полную приватность",
                "B. Декорацию",
                "C. Автоудаление",
                "D. Кэширование",
                "E. Типизацию",
                "F. Искажение имени"
            ],
            correctAnswers: ["F"],
            section: "section5"
        },
        {
            id: 112,
            text: "Class атрибут instances = [] в Student пополняется self.instances.append(self) в __init__ позволяя Student.instances показать все студенты созданные. Что отслеживает instances?",
            options: [
                "A. Экземпляры",
                "B. Атрибуты",
                "C. Методы",
                "D. Константы",
                "E. Классы",
                "F. Модули"
            ],
            correctAnswers: ["A"],
            section: "section5"
        },
        {
            id: 113,
            text: "Метод __str__ в Task возвращает \"Задача #1: Купить молоко (срочно)\" для print(task) где форматирование ориентировано на конечного пользователя читаемости. Кто использует __str__?",
            options: [
                "A. Разработчики",
                "B. Тестировщики",
                "C. Пользователи",
                "D. Админы",
                "E. Отладчики",
                "F. Сборщик мусора"
            ],
            correctAnswers: ["C"],
            section: "section5"
        },
        {
            id: 114,
            text: "По SRP PaymentProcessor не должен обрабатывать платежи, логировать транзакции, отправлять email где каждая задача отделяется в классы специализированные. Что требует SRP?",
            options: [
                "A. Много обязанностей",
                "B. Одну ответственность",
                "C. Наследование",
                "D. Интерфейсы",
                "E. Композицию",
                "F. Полиморфизм"
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 115,
            text: "Цепочка свойств в Coordinate x y где x.setter обновляет self._point а point обновляется автоматически синхронизируя представления. Что обновляет setter x?",
            options: [
                "A. Связанные свойства",
                "B. Только x",
                "C. Кэш",
                "D. Базу данных",
                "E. Файлы",
                "F. Логи"
            ],
            correctAnswers: ["A"],
            section: "section5"
        },
        {
            id: 116,
            text: "Что требует __hash__ в FrozenDict hash(tuple(sorted(self.items()))) ?",
            options: [
                "A. Изменяемые объекты",
                "B. Неизменяемые объекты",
                "C. Списки",
                "D. Сеты",
                "E. Словари",
                "F. Все выше"
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 117,
            text: "Как в рамках принципа OCP добавляют поддержку OracleDatabase, если UserService работает через абстракцию Database с методом save()?",
            options: [
                "A. Вносят изменения в код UserService.",
                "B. Создают новый класс OracleDatabase, реализующий Database.",
                "C. Добавляют условие if type == \"oracle\" в UserService.",
                "D. Изменяют интерфейс или абстрактный класс Database.",
                "E. Копируют и дублируют существующую реализацию.",
                "F. Используют switch для выбора типа базы данных"
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 118,
            text: "Какая функция проверяет, является ли объект экземпляром класса или его подкласса?",
            options: [
                "A. checktype()",
                "B. classcheck()",
                "C. isinstance()",
                "D. typetest()",
                "E. belongsto()",
                "F. isclass()"
            ],
            correctAnswers: ["C"],
            section: "section5"
        },
        {
            id: 119,
            text: "Как получить значение атрибута extension класса HtmlDocument с значением по умолчанию, если атрибут отсутствует?",
            options: [
                "A. HtmlDocument.get('extension')",
                "B. attrget(HtmlDocument, 'extension')",
                "C. HtmlDocument['extension']",
                "D. get(HtmlDocument, 'extension')",
                "E. getattr(HtmlDocument, 'extension', 'default')",
                "F. HtmlDocument.fetch('extension')"
            ],
            correctAnswers: ["E"],
            section: "section5"
        },
        {
            id: 120,
            text: "Какой встроенный механизм Python используется для динамического добавления атрибута классу или объекту?",
            options: [
                "A. addattr()",
                "B. assignattr()",
                "C. appendattr()",
                "D. insertattr()",
                "E. putattr()",
                "F. setattr()"
            ],
            correctAnswers: ["F"],
            section: "section5"
        },
        {
            id: 121,
            text: "Какой встроенный способ используется для удаления атрибута у класса или объекта?",
            options: [
                "A. delattr()",
                "B. removeattr()",
                "C. deleteattr()",
                "D. clearattr()",
                "E. rmattr()",
                "F. dropattr()"
            ],
            correctAnswers: ["A"],
            section: "section5"
        },
        {
            id: 122,
            text: "Что обеспечивает инкапсуляция в объектно-ориентированном программировании?",
            options: [
                "A. Повышение скорости выполнения",
                "B. Сокрытие внутреннего состояния объекта",
                "C. Поддержку наследования",
                "D. Реализацию полиморфизма",
                "E. Возможность хеширования",
                "F. Автоматическое кэширование"
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 123,
            text: "Какой метод вызывается для получения читаемого строкового представления объекта?",
            options: [
                "A. repr()",
                "B. print()",
                "C. str()",
                "D. hash()",
                "E. bool()",
                "F. len()"
            ],
            correctAnswers: ["B", "C"],
            section: "section5"
        },
        {
            id: 124,
            text: "Где обязательно использовать метод __repr__ для корректного представления объектов?",
            options: [
                "A. В списках и других коллекциях",
                "B. При вызове print()",
                "C. В вызове str()",
                "D. В f-строках",
                "E. В условных выражениях (if obj)",
                "F. В функции len(obj)"
            ],
            correctAnswers: ["A"],
            section: "section5"
        },
        {
            id: 125,
            text: "Что проверяет функция isinstance(obj, Class)?",
            options: [
                "A. Равенство объектов класса друг с другом",
                "B. Совместимость типа объекта с классом",
                "C. Хеш объекта",
                "D. Идентичность объектов",
                "E. Наследование классов",
                "F. Метакласс объекта"
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 126,
            text: "hash((self.x, self.y)) обязательна при __eq__ для работы в set dict где изменяемые атрибуты требуют @property readonly. Для чего нужен метод __hash__ в классе?",
            options: [
                "A. Сортировка",
                "B. Сравнение",
                "C. Хеш-таблицы",
                "D. Кэширование",
                "E. Сериализация",
                "F. Логирование"
            ],
            correctAnswers: ["C"],
            section: "section5"
        },
        {
            id: 127,
            text: "Декоратор @property def full_name(self): создает свойство где чтение obj.full_name вызывает метод автоматически а @full_name.setter добавляет запись с валидацией. Что делает декоратор @property у метода класса?",
            options: [
                "A. Setter",
                "B. Getter",
                "C. Deleter",
                "D. Validator",
                "E. Cache",
                "F. Serializer"
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 128,
            text: "Readonly свойство area в Rectangle вычисляет self.width * self.height без @area.setter где прямое area = 50 вызовет AttributeError защищая логику. Какой декоратор отсутствует у Read-only свойства, если оно нельзя изменить?",
            options: [
                "A. @property",
                "B. @attr.setter",
                "C. @att.getter",
                "D. Типизация",
                "E. @<property>.setter",
                "F. Логирование"
            ],
            correctAnswers: ["B", "E"],
            section: "section5"
        },
        {
            id: 129,
            text: "class Point: def __eq__(self, other): epsilon = 1e-9 return abs(self.x - other.x) < epsilon Зачем epsilon в __eq__?",
            options: [
                "A. Точность float",
                "B. Погрешность целого числа",
                "C. Типизация",
                "D. Хеширование",
                "E. Кэширование",
                "F. Логирование"
            ],
            correctAnswers: ["A"],
            section: "section5"
        },
        {
            id: 130,
            text: "class Person: pass print(type(Person)) Какой тип имеет объект класса Person?",
            options: [
                "A. class",
                "B. object",
                "C. type",
                "D. instance",
                "E. module",
                "F. function"
            ],
            correctAnswers: ["C"],
            section: "section5"
        },
        {
            id: 131,
            text: "Какая функция преобразует идентификатор объекта в шестнадцатеричную строку?",
            options: [
                "A. tohex()",
                "B. format()",
                "C. hex()",
                "D. strid()",
                "E. address()",
                "F. memhex()"
            ],
            correctAnswers: ["C"],
            section: "section5"
        },
        {
            id: 132,
            text: "Что представляет __dict__ класса?\nclass MyClass:\n    x = 10\n    y = 20\nprint(MyClass.__dict__)",
            options: [
                "A. Список методов",
                "B. Словарь атрибутов",
                "C. Набор экземпляров",
                "D. Кэш значений",
                "E. Метаданные",
                "F. Константы"
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 133,
            text: "Какая функция удаляет атрибут динамически?",
            options: [
                "A. removeattr()",
                "B. clearattr()",
                "C. delattr()",
                "D. rmattr()",
                "E. deleteattr()",
                "F. unsetattr()"
            ],
            correctAnswers: ["C"],
            section: "section5"
        },
        {
            id: 134,
            text: "Что происходит с функцией класса при вызове через экземпляр?",
            options: [
                "A. Ошибка",
                "B. Становится методом",
                "C. Игнорируется",
                "D. Вызывается статично",
                "E. Требует self вручную",
                "F. Копируется"
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 135,
            text: "Сколько методов в классе Counter в примере?\nclass Counter:\n    _current = 0\n    def increment(self):\n        self._current += 1\n    def value(self):\n        return self._current\n    def reset(self):\n        self._current = 0",
            options: [
                "A. 1",
                "B. 2",
                "C. 3",
                "D. 4",
                "E. 5",
                "F. 6"
            ],
            correctAnswers: ["D"],
            section: "section5"
        },
        {
            id: 136,
            text: "При искажении имен атрибут __current в классе Counter становится _Counter__current доступным через obj._Counter__current но прямое obj.__current вызовет AttributeError. Что делает двойное подчеркивание в начале атрибута?",
            options: [
                "A. Делает публичным",
                "B. Искажает имя",
                "C. Удаляет атрибут",
                "D. Делает статическим",
                "E. Кэширует значение",
                "F. Делает константой"
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 137,
            text: "Что возвращает test.x, если есть атрибут класса и экземпляра с одинаковым именем?\nclass Test:\n    x = 10\n    def __init__(self):\n        self.x = 20\n\ntest = Test()\nprint(test.x)",
            options: [
                "A. Class x",
                "B. Случайный",
                "C. None",
                "D. AttributeError",
                "E. Первый найденный",
                "F. Instance x"
            ],
            correctAnswers: ["F"],
            section: "section5"
        },
        {
            id: 138,
            text: "Где инициализируется атрибут circle_list в классе Circle?\nclass Circle:\n    circle_list = []\n    def __init__(self):\n        self.circle_list.append(self)",
            options: [
                "A. В init",
                "B. Вне методов",
                "C. В new",
                "D. В метаклассе",
                "E. В модуле",
                "F. В глобально"
            ],
            correctAnswers: ["A", "B"],
            section: "section5"
        },
        {
            id: 139,
            text: "eval(repr(obj)) == obj. Где __repr__ используется автоматически?",
            options: [
                "A. print(obj)",
                "B. str(obj)",
                "C. [obj]",
                "D. f\"{obj}\"",
                "E. bool(obj)",
                "F. len(obj)"
            ],
            correctAnswers: ["C"],
            section: "section5"
        },
        {
            id: 140,
            text: "Метод __bool__ имеет приоритет над __len__ в логических контекстах где if obj: , while obj: , not obj: вызывают __bool__ возвращая строго bool. Что вызывает __bool__?",
            options: [
                "A. str(obj)",
                "B. if obj:",
                "C. len(obj)",
                "D. obj and x",
                "E. print(obj)",
                "F. hash(obj)"
            ],
            correctAnswers: ["B", "D"],
            section: "section5"
        },
        {
            id: 141,
            text: "Почему избегают использования __del__ для управления ресурсами?",
            options: [
                "A. Медленный",
                "B. Непредсказуемый",
                "C. Подавляет ошибки",
                "D. Неэффективный",
                "E. Все выше",
                "F. Только логирование"
            ],
            correctAnswers: ["B", "C"],
            section: "section5"
        },
        {
            id: 142,
            text: "Когда вызывается setter свойства с @attr.setter?\nclass MyClass:\n    @property\n    def attr(self):\n        return self._attr\n    @attr.setter\n    def attr(self, value):\n        self._attr = value\n\nobj = MyClass()\nobj.attr = 5",
            options: [
                "A. Чтение attr",
                "B. Копирование",
                "C. Удаление attr",
                "D. Создание obj",
                "E. Запись attr",
                "F. Сериализация"
            ],
            correctAnswers: ["E"],
            section: "section5"
        },
        {
            id: 143,
            text: "Как определить пустой класс в Python?",
            options: [
                "A. def Class(): pass",
                "B. interface MyClass: pass",
                "C. object MyClass(): pass",
                "D. type MyClass(): pass",
                "E. struct MyClass: pass",
                "F. class MyClass: pass"
            ],
            correctAnswers: ["F"],
            section: "section5"
        },
        {
            id: 144,
            text: "Какая функция возвращает числовой идентификатор объекта?\nperson = Person()\nprint(id(person))",
            options: [
                "A. type()",
                "B. str()",
                "C. id()",
                "D. hash()",
                "E. addr()",
                "F. memory()"
            ],
            correctAnswers: ["C"],
            section: "section5"
        },
        {
            id: 145,
            text: "Какой атрибут доступен извне при Name Mangling?",
            options: [
                "A. _Counter__current",
                "B. __Counter_current",
                "C. Counter___current",
                "D. _current_Counter",
                "E. current___Counter",
                "F. __current_Counter"
            ],
            correctAnswers: ["A"],
            section: "section5"
        },
        {
            id: 146,
            text: "Для чего лучше использовать атрибуты класса?",
            options: [
                "A. Уникальные данные экземпляра",
                "B. Константы общие для класса",
                "C. Временные вычисления",
                "D. Методы экземпляра",
                "E. Локальные переменные",
                "F. Глобальные настройки"
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 147,
            text: "Какая проверка обязательна в начале __eq__?\ndef __eq__(self, other):\n    if isinstance(other, self.__class__):\n        return self.value == other.value",
            options: [
                "A. if type(other) == self.__class__",
                "B. if isinstance(other, self.__class__)",
                "C. if other is not None",
                "D. if hasattr(other, 'attr')",
                "E. if callable(other)",
                "F. if hash(other) == hash(self)"
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 148,
            text: "Как называется хранилище свойства с @property?\nclass Person:\n    @property\n    def age(self):\n        return self._age\n    @age.setter\n    def age(self, value):\n        self._age = value",
            options: [
                "A. age",
                "B. self.age",
                "C. _age",
                "D. age_storage",
                "E. __age",
                "F. private_age"
            ],
            correctAnswers: ["C"],
            section: "section5"
        },
        {
            id: 149,
            text: "Где хранятся переменные класса?",
            options: [
                "A. instance.__dict__",
                "B. Class.__dict__",
                "C. global_dict",
                "D. module_dict",
                "E. static_dict",
                "F. shared_dict"
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 150,
            text: "Что возвращает c.pi если pi только в классе?\nclass Circle:\n    pi = 3.14159\n    def __init__(self, radius):\n        self.radius = radius\n\nc = Circle(1)\nprint(c.pi)",
            options: [
                "A. AttributeError",
                "B. None",
                "C. Значение класса",
                "D. Значение instance",
                "E. KeyError",
                "F. Значение глобальное"
            ],
            correctAnswers: ["C"],
            section: "section5"
        },
        {
            id: 151,
            text: "Какой синтаксис используется для setter свойства name?\nclass Person:\n    @property\n    def name(self):\n        return self._name\n    @name.setter\n    def name(self, value):\n        self._name = value",
            options: [
                "A. @name_setter",
                "B. @setter",
                "C. @name.setter",
                "D. @property.setter",
                "E. @set_name",
                "F. @attrsetter"
            ],
            correctAnswers: ["C"],
            section: "section5"
        },
        {
            id: 152,
            text: "Что представляет собой первый параметр self в методах экземпляра класса?",
            options: [
                "A. Ссылку на класс, к которому принадлежит метод.",
                "B. Ссылку на конкретный экземпляр объекта, который вызвал метод.",
                "C. Ссылку на родительский класс, если существует наследование.",
                "D. Ссылку на пространство имён модуля, в котором объявлен класс.",
                "E. Копию объекта, созданную при вызове метода.",
                "F. Неявно созданный объект для хранения локальных переменных метода."
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 153,
            text: "В какой момент жизненного цикла объекта вызывается метод __init__?",
            options: [
                "A. После вызова __new__ и фактического создания объекта.",
                "B. Только при ручном вызове, подобно обычной функции.",
                "C. Перед созданием объекта для выделения памяти.",
                "D. При каждом обращении к атрибутам экземпляра.",
                "E. До выполнения кода конструктора __new__.",
                "F. Только при наследовании от базового класса."
            ],
            correctAnswers: ["A"],
            section: "section5"
        },
        {
            id: 154,
            text: "Какая встроенная функция Python, примененная к объекту, неявно вызывает метод __str__?",
            options: [
                "A. repr()",
                "B. len()",
                "C. print()",
                "D. type()",
                "E. bool()",
                "F. format()"
            ],
            correctAnswers: ["C"],
            section: "section5"
        },
        {
            id: 155,
            text: "Что такое класс?",
            options: [
                "A. Конкретный экземпляр в памяти",
                "B. Шаблон для создания объектов",
                "C. Набор функций",
                "D. Модуль Python",
                "E. Декоратор",
                "F. Итератор"
            ],
            correctAnswers: ["B"],
            section: "section5"
        },
        {
            id: 156,
            text: "Что такое объект?",
            options: [
                "A. Класс",
                "B. Экземпляр класса",
                "C. Функция",
                "D. Модуль",
                "E. Декоратор",
                "F. Метод"
            ],
            correctAnswers: ["B"],
            section: "section5"
        }
    ],

    // Методы для работы с вопросами
    getQuestionById: function (id) {
        const question = this.questions.find(q => q.id === parseInt(id));
        if (!question) {
            console.error(`Вопрос с id ${id} не найден`);
            return null;
        }
        return question;
    },

    getQuestionsBySection: function (sectionId) {
        return this.questions.filter(q => q.section === sectionId);
    },

    getAllQuestions: function () {
        return this.questions;
    },

    getRandomQuestions: function (count) {
        const shuffled = [...this.questions].sort(() => 0.5 - Math.random());
        return shuffled.slice(0, count);
    },

    checkAnswer: function (questionId, selectedAnswers) {
        const question = this.getQuestionById(questionId);
        if (!question) return false;

        // Для вопросов с одним правильным ответом
        if (question.correctAnswers.length === 1) {
            return selectedAnswers.length === 1 &&
                selectedAnswers[0] === question.correctAnswers[0];
        }

        // Для вопросов с несколькими правильными ответами
        if (selectedAnswers.length !== question.correctAnswers.length) {
            return false;
        }

        const correctSorted = [...question.correctAnswers].sort();
        const selectedSorted = [...selectedAnswers].sort();

        return correctSorted.every((val, index) => val === selectedSorted[index]);
    },

    // Получение статистики по разделам
    getSectionStats: function (userAnswers) {
        const stats = {};

        for (const sectionId in this.sections) {
            stats[sectionId] = {
                name: this.sections[sectionId].name,
                total: this.sections[sectionId].questions.length,
                answered: 0,
                correct: 0
            };

            this.sections[sectionId].questions.forEach(questionId => {
                const answer = userAnswers[questionId];
                if (answer) {
                    stats[sectionId].answered++;
                    if (answer.correct) {
                        stats[sectionId].correct++;
                    }
                }
            });
        }

        return stats;
    }
};

// Экспорт для использования в других файлах
if (typeof module !== 'undefined' && module.exports) {
    module.exports = examQuestions;
}